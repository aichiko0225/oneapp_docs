<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Flutter Downloader &#x6587;&#x4ef6;&#x4e0b;&#x8f7d;&#x5668;&#x6a21;&#x5757;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="flutter-downloader-文件下载器模块">Flutter Downloader 文件下载器模块</h1>
<h2 id="模块概述">模块概述</h2>
<p><code>flutter_downloader</code> 是 OneApp 基础工具模块群中的文件下载器模块，基于 Flutter Community 的开源项目进行定制化。该模块提供了强大的文件下载能力，支持多平台（Android、iOS、鸿蒙）的原生下载功能，包括后台下载、断点续传、下载管理等特性。</p>
<h3 id="基本信息">基本信息</h3>
<ul>
<li><strong>模块名称</strong>: flutter_downloader</li>
<li><strong>版本</strong>: 1.11.8</li>
<li><strong>描述</strong>: 强大的文件下载插件</li>
<li><strong>Flutter 版本</strong>: &gt;=3.19.0</li>
<li><strong>Dart 版本</strong>: &gt;=3.3.0 &lt;4.0.0</li>
<li><strong>原始项目</strong>: <a href="https://github.com/fluttercommunity/flutter_downloader">https://github.com/fluttercommunity/flutter_downloader</a></li>
</ul>
<h2 id="功能特性">功能特性</h2>
<h3 id="核心功能">核心功能</h3>
<ol>
<li>
<p><strong>多平台下载支持</strong></p>
<ul>
<li>Android 原生下载管理器集成</li>
<li>iOS 后台下载任务支持</li>
<li>鸿蒙（HarmonyOS）平台支持</li>
<li>跨平台统一接口</li>
</ul>
</li>
<li>
<p><strong>高级下载特性</strong></p>
<ul>
<li>后台下载支持</li>
<li>断点续传功能</li>
<li>下载进度监控</li>
<li>并发下载控制</li>
</ul>
</li>
<li>
<p><strong>下载管理系统</strong></p>
<ul>
<li>下载任务队列</li>
<li>下载状态跟踪</li>
<li>下载历史记录</li>
<li>失败重试机制</li>
</ul>
</li>
<li>
<p><strong>文件系统集成</strong></p>
<ul>
<li>灵活的保存路径配置</li>
<li>文件完整性验证</li>
<li>存储空间检查</li>
<li>文件权限管理</li>
</ul>
</li>
</ol>
<h2 id="技术架构">技术架构</h2>
<h3 id="目录结构">目录结构</h3>
<pre><code>flutter_downloader/
├── lib/                        # Dart代码
│   ├── flutter_downloader.dart # 主入口文件
│   └── src/                    # 源代码
│       ├── downloader.dart     # 下载器核心
│       ├── models.dart         # 数据模型
│       ├── callback_dispatcher.dart # 回调分发器
│       └── utils.dart          # 工具类
├── android/                    # Android原生实现
│   └── src/main/java/
│       └── vn/hunghd/flutterdownloader/
│           ├── FlutterDownloaderPlugin.java
│           ├── DownloadWorker.java
│           ├── TaskDbHelper.java
│           └── TaskDao.java
├── ios/                        # iOS原生实现
│   ├── Classes/
│   │   ├── FlutterDownloaderPlugin.h
│   │   ├── FlutterDownloaderPlugin.m
│   │   ├── DBManager.h
│   │   └── DBManager.m
│   └── flutter_downloader.podspec
├── ohos/                       # 鸿蒙原生实现
└── example/                    # 示例应用
</code></pre>
<h3 id="平台支持">平台支持</h3>
<ul>
<li><strong>Android</strong>: 使用 DownloadManager 和 WorkManager</li>
<li><strong>iOS</strong>: 使用 URLSessionDownloadTask</li>
<li><strong>鸿蒙</strong>: 使用 HarmonyOS 下载接口</li>
</ul>
<h2 id="核心模块分析">核心模块分析</h2>
<h3 id="1-flutter端实现">1. Flutter端实现</h3>
<h4 id="主入口-libflutter_downloaderdart">主入口 (<code>lib/flutter_downloader.dart</code>)</h4>
<pre><code class="language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterDownloader</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MethodChannel _channel = MethodChannel(<span class="hljs-string">&#x27;vn.hunghd/downloader&#x27;</span>);
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MethodChannel _backgroundChannel = 
      MethodChannel(<span class="hljs-string">&#x27;vn.hunghd/downloader_send_port&#x27;</span>);

  <span class="hljs-comment">/// <span class="language-markdown">初始化下载器</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; initialize({
    <span class="hljs-built_in">bool</span> debug = <span class="hljs-keyword">false</span>,
    <span class="hljs-built_in">bool</span> ignoreSsl = <span class="hljs-keyword">false</span>,
  }) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;initialize&#x27;</span>, {
      <span class="hljs-string">&#x27;debug&#x27;</span>: debug,
      <span class="hljs-string">&#x27;ignoreSsl&#x27;</span>: ignoreSsl,
    });
  }

  <span class="hljs-comment">/// <span class="language-markdown">创建下载任务</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String?</span>&gt; enqueue({
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> url,
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> savedDir,
    <span class="hljs-built_in">String?</span> fileName,
    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;? headers,
    <span class="hljs-built_in">bool</span> showNotification = <span class="hljs-keyword">true</span>,
    <span class="hljs-built_in">bool</span> openFileFromNotification = <span class="hljs-keyword">true</span>,
    <span class="hljs-built_in">bool</span> requiresStorageNotLow = <span class="hljs-keyword">false</span>,
    <span class="hljs-built_in">bool</span> saveInPublicStorage = <span class="hljs-keyword">false</span>,
  }) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;enqueue&#x27;</span>, {
        <span class="hljs-string">&#x27;url&#x27;</span>: url,
        <span class="hljs-string">&#x27;saved_dir&#x27;</span>: savedDir,
        <span class="hljs-string">&#x27;file_name&#x27;</span>: fileName,
        <span class="hljs-string">&#x27;headers&#x27;</span>: headers,
        <span class="hljs-string">&#x27;show_notification&#x27;</span>: showNotification,
        <span class="hljs-string">&#x27;open_file_from_notification&#x27;</span>: openFileFromNotification,
        <span class="hljs-string">&#x27;requires_storage_not_low&#x27;</span>: requiresStorageNotLow,
        <span class="hljs-string">&#x27;save_in_public_storage&#x27;</span>: saveInPublicStorage,
      });
      <span class="hljs-keyword">return</span> result;
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error creating download task: <span class="hljs-subst">$e</span>&#x27;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
  }

  <span class="hljs-comment">/// <span class="language-markdown">获取所有下载任务</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">List</span>&lt;DownloadTask&gt;?&gt; loadTasks() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;loadTasks&#x27;</span>);
      <span class="hljs-keyword">return</span> (result <span class="hljs-keyword">as</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">dynamic</span>&gt;?)
          ?.map((item) =&gt; DownloadTask.fromMap(item))
          .toList();
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error loading tasks: <span class="hljs-subst">$e</span>&#x27;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
  }

  <span class="hljs-comment">/// <span class="language-markdown">取消下载任务</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; cancel({<span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> taskId}) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;cancel&#x27;</span>, {<span class="hljs-string">&#x27;task_id&#x27;</span>: taskId});
  }

  <span class="hljs-comment">/// <span class="language-markdown">暂停下载任务</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; pause({<span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> taskId}) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;pause&#x27;</span>, {<span class="hljs-string">&#x27;task_id&#x27;</span>: taskId});
  }

  <span class="hljs-comment">/// <span class="language-markdown">恢复下载任务</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; resume({<span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> taskId}) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;resume&#x27;</span>, {<span class="hljs-string">&#x27;task_id&#x27;</span>: taskId});
  }

  <span class="hljs-comment">/// <span class="language-markdown">重试下载任务</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String?</span>&gt; retry({<span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> taskId}) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;retry&#x27;</span>, {<span class="hljs-string">&#x27;task_id&#x27;</span>: taskId});
  }

  <span class="hljs-comment">/// <span class="language-markdown">移除下载任务</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; remove({
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> taskId,
    <span class="hljs-built_in">bool</span> shouldDeleteContent = <span class="hljs-keyword">false</span>,
  }) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;remove&#x27;</span>, {
      <span class="hljs-string">&#x27;task_id&#x27;</span>: taskId,
      <span class="hljs-string">&#x27;should_delete_content&#x27;</span>: shouldDeleteContent,
    });
  }

  <span class="hljs-comment">/// <span class="language-markdown">打开下载的文件</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">bool</span>&gt; open({<span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> taskId}) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;open&#x27;</span>, {<span class="hljs-string">&#x27;task_id&#x27;</span>: taskId});
  }

  <span class="hljs-comment">/// <span class="language-markdown">注册下载回调</span></span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> registerCallback(DownloadCallback callback) {
    _callback = callback;
    _channel.setMethodCallHandler(_handleMethodCall);
  }

  <span class="hljs-keyword">static</span> DownloadCallback? _callback;

  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">dynamic</span>&gt; _handleMethodCall(MethodCall call) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">if</span> (call.method == <span class="hljs-string">&#x27;updateProgress&#x27;</span>) {
      <span class="hljs-keyword">final</span> id = call.arguments[<span class="hljs-string">&#x27;id&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>;
      <span class="hljs-keyword">final</span> status = DownloadTaskStatus.values[call.arguments[<span class="hljs-string">&#x27;status&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>];
      <span class="hljs-keyword">final</span> progress = call.arguments[<span class="hljs-string">&#x27;progress&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;
      _callback?.call(id, status, progress);
    }
  }
}

<span class="hljs-keyword">typedef</span> DownloadCallback = <span class="hljs-keyword">void</span> <span class="hljs-built_in">Function</span>(
  <span class="hljs-built_in">String</span> id,
  DownloadTaskStatus status,
  <span class="hljs-built_in">int</span> progress,
);
</code></pre>
<h4 id="数据模型-srcmodelsdart">数据模型 (<code>src/models.dart</code>)</h4>
<pre><code class="language-dart"><span class="hljs-keyword">enum</span> DownloadTaskStatus {
  undefined,
  enqueued,
  running,
  complete,
  failed,
  canceled,
  paused,
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadTask</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> taskId;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> url;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> filename;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> savedDir;
  <span class="hljs-keyword">final</span> DownloadTaskStatus status;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> progress;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> timeCreated;
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> allowCellular;
  
  <span class="hljs-keyword">const</span> DownloadTask({
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.taskId,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.url,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.filename,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.savedDir,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.status,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.progress,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.timeCreated,
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.allowCellular,
  });

  <span class="hljs-keyword">factory</span> DownloadTask.fromMap(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; map) {
    <span class="hljs-keyword">return</span> DownloadTask(
      taskId: map[<span class="hljs-string">&#x27;task_id&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>,
      url: map[<span class="hljs-string">&#x27;url&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>,
      filename: map[<span class="hljs-string">&#x27;file_name&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>,
      savedDir: map[<span class="hljs-string">&#x27;saved_dir&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>,
      status: DownloadTaskStatus.values[map[<span class="hljs-string">&#x27;status&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>],
      progress: map[<span class="hljs-string">&#x27;progress&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>,
      timeCreated: map[<span class="hljs-string">&#x27;time_created&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>,
      allowCellular: map[<span class="hljs-string">&#x27;allow_cellular&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">bool?</span> ?? <span class="hljs-keyword">true</span>,
    );
  }

  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; toMap() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-string">&#x27;task_id&#x27;</span>: taskId,
      <span class="hljs-string">&#x27;url&#x27;</span>: url,
      <span class="hljs-string">&#x27;file_name&#x27;</span>: filename,
      <span class="hljs-string">&#x27;saved_dir&#x27;</span>: savedDir,
      <span class="hljs-string">&#x27;status&#x27;</span>: status.index,
      <span class="hljs-string">&#x27;progress&#x27;</span>: progress,
      <span class="hljs-string">&#x27;time_created&#x27;</span>: timeCreated,
      <span class="hljs-string">&#x27;allow_cellular&#x27;</span>: allowCellular,
    };
  }
}
</code></pre>
<h3 id="2-android端实现">2. Android端实现</h3>
<h4 id="主插件类-flutterdownloaderpluginjava">主插件类 (<code>FlutterDownloaderPlugin.java</code>)</h4>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlutterDownloaderPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlutterPlugin</span>, MethodCallHandler {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CHANNEL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;vn.hunghd/downloader&quot;</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BACKGROUND_CHANNEL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;vn.hunghd/downloader_send_port&quot;</span>;
    
    <span class="hljs-keyword">private</span> Context context;
    <span class="hljs-keyword">private</span> MethodChannel channel;
    <span class="hljs-keyword">private</span> MethodChannel backgroundChannel;
    <span class="hljs-keyword">private</span> TaskDbHelper dbHelper;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAttachedToEngine</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FlutterPluginBinding binding)</span> {
        context = binding.getApplicationContext();
        channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChannel</span>(binding.getBinaryMessenger(), CHANNEL);
        backgroundChannel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChannel</span>(binding.getBinaryMessenger(), BACKGROUND_CHANNEL);
        channel.setMethodCallHandler(<span class="hljs-built_in">this</span>);
        dbHelper = TaskDbHelper.getInstance(context);
    }
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodCall</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MethodCall call, <span class="hljs-meta">@NonNull</span> Result result)</span> {
        <span class="hljs-keyword">switch</span> (call.method) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;initialize&quot;</span>:
                initialize(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;enqueue&quot;</span>:
                enqueue(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;loadTasks&quot;</span>:
                loadTasks(result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;cancel&quot;</span>:
                cancel(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pause&quot;</span>:
                pause(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;resume&quot;</span>:
                resume(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;retry&quot;</span>:
                retry(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;remove&quot;</span>:
                remove(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;open&quot;</span>:
                open(call, result);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                result.notImplemented();
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(MethodCall call, Result result)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> call.argument(<span class="hljs-string">&quot;url&quot;</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">savedDir</span> <span class="hljs-operator">=</span> call.argument(<span class="hljs-string">&quot;saved_dir&quot;</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> call.argument(<span class="hljs-string">&quot;file_name&quot;</span>);
        Map&lt;String, String&gt; headers = call.argument(<span class="hljs-string">&quot;headers&quot;</span>);
        <span class="hljs-type">boolean</span> <span class="hljs-variable">showNotification</span> <span class="hljs-operator">=</span> call.argument(<span class="hljs-string">&quot;show_notification&quot;</span>);
        
        <span class="hljs-comment">// 创建下载请求</span>
        DownloadManager.<span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadManager</span>.Request(Uri.parse(url));
        
        <span class="hljs-comment">// 设置请求头</span>
        <span class="hljs-keyword">if</span> (headers != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : headers.entrySet()) {
                request.addRequestHeader(entry.getKey(), entry.getValue());
            }
        }
        
        <span class="hljs-comment">// 设置下载路径</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">finalFileName</span> <span class="hljs-operator">=</span> fileName != <span class="hljs-literal">null</span> ? fileName : 
            URLUtil.guessFileName(url, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
        request.setDestinationInExternalFilesDir(context, <span class="hljs-literal">null</span>, 
            savedDir + <span class="hljs-string">&quot;/&quot;</span> + finalFileName);
        
        <span class="hljs-comment">// 设置通知</span>
        <span class="hljs-keyword">if</span> (showNotification) {
            request.setNotificationVisibility(
                DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
        }
        
        <span class="hljs-comment">// 启动下载</span>
        <span class="hljs-type">DownloadManager</span> <span class="hljs-variable">downloadManager</span> <span class="hljs-operator">=</span> (DownloadManager) 
            context.getSystemService(Context.DOWNLOAD_SERVICE);
        <span class="hljs-type">long</span> <span class="hljs-variable">downloadId</span> <span class="hljs-operator">=</span> downloadManager.enqueue(request);
        
        <span class="hljs-comment">// 保存任务信息到数据库</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();
        <span class="hljs-type">TaskDao</span> <span class="hljs-variable">taskDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskDao</span>(taskId, url, finalFileName, savedDir, 
            DownloadTaskStatus.ENQUEUED.ordinal(), <span class="hljs-number">0</span>, System.currentTimeMillis());
        dbHelper.insertOrUpdateNewTask(taskDao);
        
        result.success(taskId);
    }
}
</code></pre>
<h4 id="下载工作器-downloadworkerjava">下载工作器 (<code>DownloadWorker.java</code>)</h4>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DownloadWorker</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@NonNull</span> WorkerParameters params)</span> {
        <span class="hljs-built_in">super</span>(context, params);
    }
    
    <span class="hljs-meta">@NonNull</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> getInputData().getString(<span class="hljs-string">&quot;task_id&quot;</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> getInputData().getString(<span class="hljs-string">&quot;url&quot;</span>);
        
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行下载逻辑</span>
            downloadFile(taskId, url);
            <span class="hljs-keyword">return</span> Result.success();
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">return</span> Result.failure();
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadFile</span><span class="hljs-params">(String taskId, String url)</span> {
        <span class="hljs-comment">// 下载实现逻辑</span>
        <span class="hljs-comment">// 包括进度更新、错误处理等</span>
    }
}
</code></pre>
<h3 id="3-ios端实现">3. iOS端实现</h3>
<h4 id="主插件类-flutterdownloaderpluginm">主插件类 (<code>FlutterDownloaderPlugin.m</code>)</h4>
<pre><code class="language-objc"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FlutterDownloaderPlugin</span></span>

+ (<span class="hljs-type">void</span>)registerWithRegistrar:(<span class="hljs-built_in">NSObject</span>&lt;FlutterPluginRegistrar&gt;*)registrar {
    FlutterMethodChannel* channel = [FlutterMethodChannel
        methodChannelWithName:<span class="hljs-string">@&quot;vn.hunghd/downloader&quot;</span>
              binaryMessenger:[registrar messenger]];
    FlutterDownloaderPlugin* instance = [[FlutterDownloaderPlugin alloc] init];
    [registrar addMethodCallDelegate:instance channel:channel];
}

- (<span class="hljs-type">void</span>)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {
    <span class="hljs-keyword">if</span> ([<span class="hljs-string">@&quot;initialize&quot;</span> isEqualToString:call.method]) {
        [<span class="hljs-keyword">self</span> initialize:call result:result];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">@&quot;enqueue&quot;</span> isEqualToString:call.method]) {
        [<span class="hljs-keyword">self</span> enqueue:call result:result];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">@&quot;loadTasks&quot;</span> isEqualToString:call.method]) {
        [<span class="hljs-keyword">self</span> loadTasks:result];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">@&quot;cancel&quot;</span> isEqualToString:call.method]) {
        [<span class="hljs-keyword">self</span> cancel:call result:result];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">@&quot;pause&quot;</span> isEqualToString:call.method]) {
        [<span class="hljs-keyword">self</span> pause:call result:result];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-string">@&quot;resume&quot;</span> isEqualToString:call.method]) {
        [<span class="hljs-keyword">self</span> resume:call result:result];
    } <span class="hljs-keyword">else</span> {
        result(FlutterMethodNotImplemented);
    }
}

- (<span class="hljs-type">void</span>)enqueue:(FlutterMethodCall*)call result:(FlutterResult)result {
    <span class="hljs-built_in">NSString</span>* url = call.arguments[<span class="hljs-string">@&quot;url&quot;</span>];
    <span class="hljs-built_in">NSString</span>* savedDir = call.arguments[<span class="hljs-string">@&quot;saved_dir&quot;</span>];
    <span class="hljs-built_in">NSString</span>* fileName = call.arguments[<span class="hljs-string">@&quot;file_name&quot;</span>];
    <span class="hljs-built_in">NSDictionary</span>* headers = call.arguments[<span class="hljs-string">@&quot;headers&quot;</span>];
    
    <span class="hljs-comment">// 创建下载任务</span>
    <span class="hljs-built_in">NSURLSessionConfiguration</span>* config = [<span class="hljs-built_in">NSURLSessionConfiguration</span> backgroundSessionConfigurationWithIdentifier:[[<span class="hljs-built_in">NSUUID</span> UUID] UUIDString]];
    <span class="hljs-built_in">NSURLSession</span>* session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:config delegate:<span class="hljs-keyword">self</span> delegateQueue:<span class="hljs-literal">nil</span>];
    
    <span class="hljs-built_in">NSMutableURLRequest</span>* request = [<span class="hljs-built_in">NSMutableURLRequest</span> requestWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:url]];
    
    <span class="hljs-comment">// 设置请求头</span>
    <span class="hljs-keyword">if</span> (headers) {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span>* key <span class="hljs-keyword">in</span> headers) {
            [request setValue:headers[key] forHTTPHeaderField:key];
        }
    }
    
    <span class="hljs-built_in">NSURLSessionDownloadTask</span>* downloadTask = [session downloadTaskWithRequest:request];
    [downloadTask resume];
    
    <span class="hljs-comment">// 生成任务ID并保存</span>
    <span class="hljs-built_in">NSString</span>* taskId = [[<span class="hljs-built_in">NSUUID</span> UUID] UUIDString];
    [[DBManager getInstance] insertTask:taskId url:url fileName:fileName savedDir:savedDir];
    
    result(taskId);
}

<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - NSURLSessionDownloadDelegate</span>

- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="hljs-built_in">NSURL</span> *)location {
    <span class="hljs-comment">// 处理下载完成</span>
}

- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    <span class="hljs-comment">// 更新下载进度</span>
    <span class="hljs-type">double</span> progress = (<span class="hljs-type">double</span>)totalBytesWritten / (<span class="hljs-type">double</span>)totalBytesExpectedToWrite;
    <span class="hljs-comment">// 通知Flutter端进度更新</span>
}

<span class="hljs-keyword">@end</span>
</code></pre>
<h2 id="业务流程">业务流程</h2>
<h3 id="下载任务生命周期">下载任务生命周期</h3>
<pre><code class="language-mermaid">graph TD
    A[创建下载任务] --&gt; B[任务入队]
    B --&gt; C[开始下载]
    C --&gt; D[下载进行中]
    D --&gt; E{下载结果}
    E --&gt;|成功| F[下载完成]
    E --&gt;|失败| G[下载失败]
    E --&gt;|取消| H[任务取消]
    E --&gt;|暂停| I[任务暂停]
    
    F --&gt; J[通知用户]
    G --&gt; K[错误处理]
    H --&gt; L[清理资源]
    I --&gt; M[可恢复状态]
    
    K --&gt; N{是否重试}
    N --&gt;|是| C
    N --&gt;|否| L
    
    M --&gt; O[恢复下载]
    O --&gt; C
</code></pre>
<h3 id="进度更新流程">进度更新流程</h3>
<pre><code class="language-mermaid">graph TD
    A[原生下载器] --&gt; B[进度计算]
    B --&gt; C[方法通道传递]
    C --&gt; D[Flutter回调处理]
    D --&gt; E[UI更新]
    
    F[定时器] --&gt; G[状态检查]
    G --&gt; H{状态是否变化}
    H --&gt;|是| I[通知状态更新]
    H --&gt;|否| J[继续监控]
    I --&gt; D
    J --&gt; G
</code></pre>
<h2 id="使用示例">使用示例</h2>
<h3 id="基础下载示例">基础下载示例</h3>
<pre><code class="language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  _DownloadExampleState createState() =&gt; _DownloadExampleState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_DownloadExampleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">DownloadExample</span>&gt; </span>{
  <span class="hljs-built_in">List</span>&lt;DownloadTask&gt; _tasks = [];
  
  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    <span class="hljs-keyword">super</span>.initState();
    _initializeDownloader();
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; _initializeDownloader() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> FlutterDownloader.initialize(debug: <span class="hljs-keyword">true</span>);
    
    <span class="hljs-comment">// 注册下载回调</span>
    FlutterDownloader.registerCallback(_downloadCallback);
    
    <span class="hljs-comment">// 加载已有任务</span>
    _loadTasks();
  }
  
  <span class="hljs-keyword">void</span> _downloadCallback(<span class="hljs-built_in">String</span> id, DownloadTaskStatus status, <span class="hljs-built_in">int</span> progress) {
    setState(() {
      <span class="hljs-keyword">final</span> taskIndex = _tasks.indexWhere((task) =&gt; task.taskId == id);
      <span class="hljs-keyword">if</span> (taskIndex != <span class="hljs-number">-1</span>) {
        _tasks[taskIndex] = DownloadTask(
          taskId: id,
          url: _tasks[taskIndex].url,
          filename: _tasks[taskIndex].filename,
          savedDir: _tasks[taskIndex].savedDir,
          status: status,
          progress: progress,
          timeCreated: _tasks[taskIndex].timeCreated,
          allowCellular: _tasks[taskIndex].allowCellular,
        );
      }
    });
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; _loadTasks() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> tasks = <span class="hljs-keyword">await</span> FlutterDownloader.loadTasks();
    setState(() {
      _tasks = tasks ?? [];
    });
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; _startDownload(<span class="hljs-built_in">String</span> url, <span class="hljs-built_in">String</span> fileName) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> savedDir = <span class="hljs-keyword">await</span> _getSavedDir();
    
    <span class="hljs-keyword">final</span> taskId = <span class="hljs-keyword">await</span> FlutterDownloader.enqueue(
      url: url,
      savedDir: savedDir,
      fileName: fileName,
      showNotification: <span class="hljs-keyword">true</span>,
      openFileFromNotification: <span class="hljs-keyword">true</span>,
    );
    
    <span class="hljs-keyword">if</span> (taskId != <span class="hljs-keyword">null</span>) {
      _loadTasks();
    }
  }
  
  Future&lt;<span class="hljs-built_in">String</span>&gt; _getSavedDir() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> directory = <span class="hljs-keyword">await</span> getExternalStorageDirectory();
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;<span class="hljs-subst">${directory!.path}</span>/downloads&#x27;</span>;
  }
  
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: Text(<span class="hljs-string">&#x27;Downloads&#x27;</span>)),
      body: ListView.builder(
        itemCount: _tasks.length,
        itemBuilder: (context, index) {
          <span class="hljs-keyword">final</span> task = _tasks[index];
          <span class="hljs-keyword">return</span> ListTile(
            title: Text(task.filename),
            subtitle: LinearProgressIndicator(
              value: task.progress / <span class="hljs-number">100.0</span>,
            ),
            trailing: _buildActionButton(task),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () =&gt; _showDownloadDialog(),
        child: Icon(Icons.add),
      ),
    );
  }
  
  Widget _buildActionButton(DownloadTask task) {
    <span class="hljs-keyword">switch</span> (task.status) {
      <span class="hljs-keyword">case</span> DownloadTaskStatus.running:
        <span class="hljs-keyword">return</span> IconButton(
          icon: Icon(Icons.pause),
          onPressed: () =&gt; FlutterDownloader.pause(taskId: task.taskId),
        );
      <span class="hljs-keyword">case</span> DownloadTaskStatus.paused:
        <span class="hljs-keyword">return</span> IconButton(
          icon: Icon(Icons.play_arrow),
          onPressed: () =&gt; FlutterDownloader.resume(taskId: task.taskId),
        );
      <span class="hljs-keyword">case</span> DownloadTaskStatus.failed:
        <span class="hljs-keyword">return</span> IconButton(
          icon: Icon(Icons.refresh),
          onPressed: () =&gt; FlutterDownloader.retry(taskId: task.taskId),
        );
      <span class="hljs-keyword">case</span> DownloadTaskStatus.complete:
        <span class="hljs-keyword">return</span> IconButton(
          icon: Icon(Icons.open_in_new),
          onPressed: () =&gt; FlutterDownloader.open(taskId: task.taskId),
        );
      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> IconButton(
          icon: Icon(Icons.delete),
          onPressed: () =&gt; FlutterDownloader.remove(
            taskId: task.taskId,
            shouldDeleteContent: <span class="hljs-keyword">true</span>,
          ),
        );
    }
  }
  
  <span class="hljs-keyword">void</span> _showDownloadDialog() {
    <span class="hljs-comment">// 显示下载URL输入对话框</span>
    showDialog(
      context: context,
      builder: (context) =&gt; DownloadDialog(
        onDownload: (url, fileName) =&gt; _startDownload(url, fileName),
      ),
    );
  }
}
</code></pre>
<h3 id="批量下载管理">批量下载管理</h3>
<pre><code class="language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchDownloadManager</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BatchDownloadManager _instance = BatchDownloadManager._internal();
  <span class="hljs-keyword">factory</span> BatchDownloadManager() =&gt; _instance;
  BatchDownloadManager._internal();
  
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, DownloadTask&gt; _activeTasks = {};
  <span class="hljs-keyword">final</span> StreamController&lt;<span class="hljs-built_in">List</span>&lt;DownloadTask&gt;&gt; _tasksController = 
      StreamController&lt;<span class="hljs-built_in">List</span>&lt;DownloadTask&gt;&gt;.broadcast();
  
  Stream&lt;<span class="hljs-built_in">List</span>&lt;DownloadTask&gt;&gt; <span class="hljs-keyword">get</span> tasksStream =&gt; _tasksController.stream;
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; initialize() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> FlutterDownloader.initialize();
    FlutterDownloader.registerCallback(_onDownloadCallback);
    <span class="hljs-keyword">await</span> _loadExistingTasks();
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; _loadExistingTasks() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> tasks = <span class="hljs-keyword">await</span> FlutterDownloader.loadTasks();
    <span class="hljs-keyword">if</span> (tasks != <span class="hljs-keyword">null</span>) {
      _activeTasks.clear();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> task <span class="hljs-keyword">in</span> tasks) {
        _activeTasks[task.taskId] = task;
      }
      _notifyTasksUpdate();
    }
  }
  
  <span class="hljs-keyword">void</span> _onDownloadCallback(<span class="hljs-built_in">String</span> id, DownloadTaskStatus status, <span class="hljs-built_in">int</span> progress) {
    <span class="hljs-keyword">final</span> existingTask = _activeTasks[id];
    <span class="hljs-keyword">if</span> (existingTask != <span class="hljs-keyword">null</span>) {
      _activeTasks[id] = DownloadTask(
        taskId: id,
        url: existingTask.url,
        filename: existingTask.filename,
        savedDir: existingTask.savedDir,
        status: status,
        progress: progress,
        timeCreated: existingTask.timeCreated,
        allowCellular: existingTask.allowCellular,
      );
      _notifyTasksUpdate();
    }
  }
  
  Future&lt;<span class="hljs-built_in">String?</span>&gt; addDownload({
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> url,
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> savedDir,
    <span class="hljs-built_in">String?</span> fileName,
    <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;? headers,
  }) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> taskId = <span class="hljs-keyword">await</span> FlutterDownloader.enqueue(
      url: url,
      savedDir: savedDir,
      fileName: fileName,
      headers: headers,
      showNotification: <span class="hljs-keyword">true</span>,
    );
    
    <span class="hljs-keyword">if</span> (taskId != <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">await</span> _loadExistingTasks();
    }
    
    <span class="hljs-keyword">return</span> taskId;
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; pauseDownload(<span class="hljs-built_in">String</span> taskId) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> FlutterDownloader.pause(taskId: taskId);
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; resumeDownload(<span class="hljs-built_in">String</span> taskId) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> FlutterDownloader.resume(taskId: taskId);
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; cancelDownload(<span class="hljs-built_in">String</span> taskId) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> FlutterDownloader.cancel(taskId: taskId);
    _activeTasks.remove(taskId);
    _notifyTasksUpdate();
  }
  
  Future&lt;<span class="hljs-keyword">void</span>&gt; retryDownload(<span class="hljs-built_in">String</span> taskId) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> newTaskId = <span class="hljs-keyword">await</span> FlutterDownloader.retry(taskId: taskId);
    <span class="hljs-keyword">if</span> (newTaskId != <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">await</span> _loadExistingTasks();
    }
  }
  
  <span class="hljs-built_in">List</span>&lt;DownloadTask&gt; getTasksByStatus(DownloadTaskStatus status) {
    <span class="hljs-keyword">return</span> _activeTasks.values
        .where((task) =&gt; task.status == status)
        .toList();
  }
  
  <span class="hljs-keyword">void</span> _notifyTasksUpdate() {
    _tasksController.add(_activeTasks.values.toList());
  }
  
  <span class="hljs-keyword">void</span> dispose() {
    _tasksController.close();
  }
}
</code></pre>
<h2 id="配置和优化">配置和优化</h2>
<h3 id="android配置">Android配置</h3>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- android/app/src/main/AndroidManifest.xml --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">provider</span>
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;vn.hunghd.flutterdownloader.DownloadedFileProvider&quot;</span>
        <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;${applicationId}.flutter_downloader.provider&quot;</span>
        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>
        <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span>
            <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/provider_paths&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
</code></pre>
<h3 id="ios配置">iOS配置</h3>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- ios/Runner/Info.plist --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSAppTransportSecurity<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>UIBackgroundModes<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>background-fetch<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>background-processing<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>
</code></pre>
<h3 id="性能优化">性能优化</h3>
<pre><code class="language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadOptimizer</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MAX_CONCURRENT_DOWNLOADS = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> RETRY_ATTEMPTS = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span> RETRY_DELAY = <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">5</span>);
  
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt; configureDownloader() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> FlutterDownloader.initialize(
      debug: kDebugMode,
      ignoreSsl: <span class="hljs-keyword">false</span>,
    );
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; getOptimizedHeaders() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;OneApp/<span class="hljs-subst">${getAppVersion()}</span>&#x27;</span>,
      <span class="hljs-string">&#x27;Accept-Encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate&#x27;</span>,
      <span class="hljs-string">&#x27;Connection&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,
    };
  }
  
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String?</span>&gt; smartDownload({
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> url,
    <span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> savedDir,
    <span class="hljs-built_in">String?</span> fileName,
  }) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 检查网络状态</span>
    <span class="hljs-keyword">final</span> connectivity = <span class="hljs-keyword">await</span> Connectivity().checkConnectivity();
    <span class="hljs-keyword">if</span> (connectivity == ConnectivityResult.none) {
      <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;No network connection&#x27;</span>);
    }
    
    <span class="hljs-comment">// 检查存储空间</span>
    <span class="hljs-keyword">final</span> directory = Directory(savedDir);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">await</span> directory.exists()) {
      <span class="hljs-keyword">await</span> directory.create(recursive: <span class="hljs-keyword">true</span>);
    }
    
    <span class="hljs-keyword">final</span> freeSpace = <span class="hljs-keyword">await</span> _getAvailableSpace(savedDir);
    <span class="hljs-keyword">final</span> fileSize = <span class="hljs-keyword">await</span> _getFileSize(url);
    <span class="hljs-keyword">if</span> (fileSize &gt; freeSpace) {
      <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&#x27;Insufficient storage space&#x27;</span>);
    }
    
    <span class="hljs-comment">// 开始下载</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> FlutterDownloader.enqueue(
      url: url,
      savedDir: savedDir,
      fileName: fileName,
      headers: getOptimizedHeaders(),
      showNotification: <span class="hljs-keyword">true</span>,
      requiresStorageNotLow: <span class="hljs-keyword">true</span>,
    );
  }
  
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">int</span>&gt; _getAvailableSpace(<span class="hljs-built_in">String</span> path) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 获取可用存储空间</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 实现细节</span>
  }
  
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">int</span>&gt; _getFileSize(<span class="hljs-built_in">String</span> url) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 获取文件大小</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 实现细节</span>
  }
}
</code></pre>
<h2 id="安全特性">安全特性</h2>
<h3 id="文件安全">文件安全</h3>
<ul>
<li><strong>路径验证</strong>: 验证下载路径安全性</li>
<li><strong>文件类型检查</strong>: 检查允许的文件类型</li>
<li><strong>病毒扫描</strong>: 集成安全扫描机制</li>
<li><strong>权限控制</strong>: 严格的文件访问权限</li>
</ul>
<h3 id="网络安全">网络安全</h3>
<ul>
<li><strong>HTTPS验证</strong>: 强制HTTPS下载</li>
<li><strong>证书校验</strong>: SSL证书有效性检查</li>
<li><strong>请求头验证</strong>: 防止恶意请求头</li>
<li><strong>下载限制</strong>: 文件大小和类型限制</li>
</ul>
<h2 id="测试策略">测试策略</h2>
<h3 id="单元测试">单元测试</h3>
<ul>
<li><strong>下载逻辑测试</strong>: 核心下载功能</li>
<li><strong>状态管理测试</strong>: 任务状态转换</li>
<li><strong>错误处理测试</strong>: 异常情况处理</li>
<li><strong>数据模型测试</strong>: 序列化反序列化</li>
</ul>
<h3 id="集成测试">集成测试</h3>
<ul>
<li><strong>平台兼容测试</strong>: 不同平台下载功能</li>
<li><strong>网络环境测试</strong>: 不同网络条件</li>
<li><strong>存储测试</strong>: 不同存储路径和权限</li>
<li><strong>并发测试</strong>: 多任务并发下载</li>
</ul>
<h3 id="性能测试">性能测试</h3>
<ul>
<li><strong>大文件下载</strong>: 大文件下载稳定性</li>
<li><strong>长时间运行</strong>: 长期后台下载</li>
<li><strong>内存使用</strong>: 内存泄漏检测</li>
<li><strong>电池消耗</strong>: 下载对电池的影响</li>
</ul>
<h2 id="总结">总结</h2>
<p><code>flutter_downloader</code> 模块作为 OneApp 的文件下载器，提供了强大的跨平台下载能力。通过原生实现和Flutter接口的完美结合，实现了高效、稳定的文件下载功能。模块支持后台下载、断点续传、进度监控等高级特性，能够满足各种下载场景的需求。良好的错误处理和性能优化机制确保了下载任务的可靠性和用户体验。</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>