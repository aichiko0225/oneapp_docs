<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>OneApp Cache Plugin &#x7f13;&#x5b58;&#x63d2;&#x4ef6;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="oneapp-cache-plugin-缓存插件">OneApp Cache Plugin 缓存插件</h1>
<h2 id="模块概述">模块概述</h2>
<p><code>one_app_cache_plugin</code> 是 OneApp 车联网生态中的原生缓存插件，负责为 Flutter 应用提供高效的原生缓存能力。该插件通过平台通道实现 Flutter 与 Android/iOS 原生缓存系统的交互，为应用数据缓存提供底层支持。</p>
<h3 id="基本信息">基本信息</h3>
<ul>
<li><strong>模块名称</strong>: one_app_cache_plugin</li>
<li><strong>版本</strong>: 0.0.4</li>
<li><strong>类型</strong>: Flutter Plugin（原生插件）</li>
<li><strong>Flutter 版本</strong>: &gt;=3.3.0</li>
<li><strong>Dart 版本</strong>: &gt;=3.0.0 &lt;4.0.0</li>
</ul>
<h2 id="功能特性">功能特性</h2>
<h3 id="核心功能">核心功能</h3>
<ol>
<li>
<p><strong>多级缓存系统</strong></p>
<ul>
<li>内存缓存（L1 Cache）</li>
<li>磁盘缓存（L2 Cache）</li>
<li>网络缓存（L3 Cache）</li>
<li>分布式缓存支持</li>
</ul>
</li>
<li>
<p><strong>缓存策略管理</strong></p>
<ul>
<li>LRU（最近最少使用）淘汰</li>
<li>LFU（最少使用频率）淘汰</li>
<li>TTL（生存时间）过期</li>
<li>自定义淘汰策略</li>
</ul>
</li>
<li>
<p><strong>数据类型支持</strong></p>
<ul>
<li>字符串数据缓存</li>
<li>二进制数据缓存</li>
<li>JSON对象缓存</li>
<li>文件资源缓存</li>
</ul>
</li>
<li>
<p><strong>性能优化</strong></p>
<ul>
<li>异步操作支持</li>
<li>批量操作优化</li>
<li>预加载机制</li>
<li>智能压缩存储</li>
</ul>
</li>
</ol>
<h2 id="技术架构">技术架构</h2>
<h3 id="目录结构">目录结构</h3>
<pre><code>one_app_cache_plugin/
├── lib/                        # Dart代码
│   ├── one_app_cache_plugin.dart    # 插件入口
│   ├── src/                    # 源代码
│   │   ├── cache_manager.dart       # 缓存管理器
│   │   ├── cache_strategy.dart      # 缓存策略
│   │   ├── cache_models.dart        # 数据模型
│   │   └── platform_interface.dart  # 平台接口
│   └── one_app_cache_plugin_platform_interface.dart
├── android/                    # Android原生代码
│   ├── src/main/kotlin/
│   │   └── com/oneapp/cache/
│   │       ├── OneAppCachePlugin.kt     # 主插件类
│   │       ├── MemoryCache.kt           # 内存缓存
│   │       ├── DiskCache.kt             # 磁盘缓存
│   │       ├── CacheStrategy.kt         # 缓存策略
│   │       └── CacheUtils.kt            # 缓存工具
│   └── build.gradle
├── ios/                        # iOS原生代码
│   ├── Classes/
│   │   ├── OneAppCachePlugin.swift      # 主插件类
│   │   ├── MemoryCache.swift            # 内存缓存
│   │   ├── DiskCache.swift              # 磁盘缓存
│   │   ├── CacheStrategy.swift          # 缓存策略
│   │   └── CacheUtils.swift             # 缓存工具
│   └── one_app_cache_plugin.podspec
├── example/                    # 示例应用
└── test/                       # 测试文件
</code></pre>
<h3 id="依赖关系">依赖关系</h3>
<h4 id="核心依赖">核心依赖</h4>
<ul>
<li><code>plugin_platform_interface: ^2.0.2</code> - 插件平台接口</li>
</ul>
<h2 id="核心模块分析">核心模块分析</h2>
<h3 id="1-flutter端实现">1. Flutter端实现</h3>
<h4 id="插件入口-libone_app_cache_plugindart">插件入口 (<code>lib/one_app_cache_plugin.dart</code>)</h4>
<pre><code class="language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneAppCachePlugin</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MethodChannel _channel = MethodChannel(<span class="hljs-string">&#x27;one_app_cache_plugin&#x27;</span>);
  
  <span class="hljs-comment">/// <span class="language-markdown">获取缓存数据</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String?</span>&gt; <span class="hljs-keyword">get</span>(<span class="hljs-built_in">String</span> key) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;get&#x27;</span>, {<span class="hljs-string">&#x27;key&#x27;</span>: key});
  }
  
  <span class="hljs-comment">/// <span class="language-markdown">设置缓存数据</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">bool</span>&gt; <span class="hljs-keyword">set</span>(<span class="hljs-built_in">String</span> key, <span class="hljs-built_in">String</span> value, {<span class="hljs-built_in">Duration?</span> ttl}) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;set&#x27;</span>, {
      <span class="hljs-string">&#x27;key&#x27;</span>: key,
      <span class="hljs-string">&#x27;value&#x27;</span>: value,
      <span class="hljs-string">&#x27;ttl&#x27;</span>: ttl?.inMilliseconds,
    });
    <span class="hljs-keyword">return</span> result ?? <span class="hljs-keyword">false</span>;
  }
  
  <span class="hljs-comment">/// <span class="language-markdown">删除缓存数据</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">bool</span>&gt; delete(<span class="hljs-built_in">String</span> key) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;delete&#x27;</span>, {<span class="hljs-string">&#x27;key&#x27;</span>: key});
    <span class="hljs-keyword">return</span> result ?? <span class="hljs-keyword">false</span>;
  }
  
  <span class="hljs-comment">/// <span class="language-markdown">清空所有缓存</span></span>
  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">bool</span>&gt; clear() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;clear&#x27;</span>);
    <span class="hljs-keyword">return</span> result ?? <span class="hljs-keyword">false</span>;
  }
  
  <span class="hljs-comment">/// <span class="language-markdown">获取缓存统计信息</span></span>
  <span class="hljs-keyword">static</span> Future&lt;CacheStats&gt; getStats() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;getStats&#x27;</span>);
    <span class="hljs-keyword">return</span> CacheStats.fromMap(result);
  }
}
</code></pre>
<h4 id="缓存管理器-libsrccache_managerdart">缓存管理器 (<code>lib/src/cache_manager.dart</code>)</h4>
<pre><code class="language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheManager</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> CacheManager _instance = CacheManager._internal();
  <span class="hljs-keyword">factory</span> CacheManager() =&gt; _instance;
  CacheManager._internal();
  
  <span class="hljs-comment">/// <span class="language-markdown">配置缓存策略</span></span>
  Future&lt;<span class="hljs-keyword">void</span>&gt; configure(CacheConfig config) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> OneAppCachePlugin.configure(config);
  }
  
  <span class="hljs-comment">/// <span class="language-markdown">智能缓存获取</span></span>
  Future&lt;T?&gt; getOrSet&lt;T&gt;(
    <span class="hljs-built_in">String</span> key,
    Future&lt;T&gt; <span class="hljs-built_in">Function</span>() valueFactory, {
    <span class="hljs-built_in">Duration?</span> ttl,
    CacheLevel level = CacheLevel.all,
  }) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 先尝试从缓存获取</span>
    <span class="hljs-keyword">final</span> cached = <span class="hljs-keyword">await</span> <span class="hljs-keyword">get</span>&lt;T&gt;(key, level: level);
    <span class="hljs-keyword">if</span> (cached != <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> cached;
    
    <span class="hljs-comment">// 缓存未命中，获取新值并缓存</span>
    <span class="hljs-keyword">final</span> value = <span class="hljs-keyword">await</span> valueFactory();
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">set</span>(key, value, ttl: ttl, level: level);
    <span class="hljs-keyword">return</span> value;
  }
  
  <span class="hljs-comment">/// <span class="language-markdown">批量操作</span></span>
  Future&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, T?&gt;&gt; getBatch&lt;T&gt;(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">String</span>&gt; keys) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> OneAppCachePlugin.getBatch(keys);
  }
  
  <span class="hljs-comment">/// <span class="language-markdown">预热缓存</span></span>
  Future&lt;<span class="hljs-keyword">void</span>&gt; preload(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; data) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> OneAppCachePlugin.preload(data);
  }
}
</code></pre>
<h3 id="2-android端实现">2. Android端实现</h3>
<h4 id="主插件类-oneappcachepluginkt">主插件类 (<code>OneAppCachePlugin.kt</code>)</h4>
<pre><code class="language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OneAppCachePlugin</span>: <span class="hljs-type">FlutterPlugin</span>, <span class="hljs-type">MethodCallHandler {</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> context: Context
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> memoryCache: MemoryCache
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> diskCache: DiskCache
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> cacheStrategy: CacheStrategy
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttachedToEngine</span><span class="hljs-params">(binding: <span class="hljs-type">FlutterPlugin</span>.<span class="hljs-type">FlutterPluginBinding</span>)</span></span> {
        context = binding.applicationContext
        initializeCaches()
        
        <span class="hljs-keyword">val</span> channel = MethodChannel(binding.binaryMessenger, <span class="hljs-string">&quot;one_app_cache_plugin&quot;</span>)
        channel.setMethodCallHandler(<span class="hljs-keyword">this</span>)
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initializeCaches</span><span class="hljs-params">()</span></span> {
        memoryCache = MemoryCache(context)
        diskCache = DiskCache(context)
        cacheStrategy = CacheStrategy()
    }
    
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onMethodCall</span><span class="hljs-params">(call: <span class="hljs-type">MethodCall</span>, result: <span class="hljs-type">Result</span>)</span></span> {
        <span class="hljs-keyword">when</span> (call.method) {
            <span class="hljs-string">&quot;get&quot;</span> -&gt; handleGet(call, result)
            <span class="hljs-string">&quot;set&quot;</span> -&gt; handleSet(call, result)
            <span class="hljs-string">&quot;delete&quot;</span> -&gt; handleDelete(call, result)
            <span class="hljs-string">&quot;clear&quot;</span> -&gt; handleClear(call, result)
            <span class="hljs-string">&quot;getStats&quot;</span> -&gt; handleGetStats(call, result)
            <span class="hljs-string">&quot;configure&quot;</span> -&gt; handleConfigure(call, result)
            <span class="hljs-keyword">else</span> -&gt; result.notImplemented()
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleGet</span><span class="hljs-params">(call: <span class="hljs-type">MethodCall</span>, result: <span class="hljs-type">Result</span>)</span></span> {
        <span class="hljs-keyword">val</span> key = call.argument&lt;String&gt;(<span class="hljs-string">&quot;key&quot;</span>)
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) {
            result.error(<span class="hljs-string">&quot;INVALID_ARGUMENT&quot;</span>, <span class="hljs-string">&quot;Key cannot be null&quot;</span>, <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">return</span>
        }
        
        <span class="hljs-comment">// 多级缓存查找</span>
        <span class="hljs-keyword">var</span> value = memoryCache.<span class="hljs-keyword">get</span>(key)
        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
            value = diskCache.<span class="hljs-keyword">get</span>(key)
            <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
                <span class="hljs-comment">// 将磁盘缓存的数据提升到内存缓存</span>
                memoryCache.<span class="hljs-keyword">set</span>(key, value)
            }
        }
        
        result.success(value)
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleSet</span><span class="hljs-params">(call: <span class="hljs-type">MethodCall</span>, result: <span class="hljs-type">Result</span>)</span></span> {
        <span class="hljs-keyword">val</span> key = call.argument&lt;String&gt;(<span class="hljs-string">&quot;key&quot;</span>)
        <span class="hljs-keyword">val</span> value = call.argument&lt;String&gt;(<span class="hljs-string">&quot;value&quot;</span>)
        <span class="hljs-keyword">val</span> ttl = call.argument&lt;<span class="hljs-built_in">Long</span>&gt;(<span class="hljs-string">&quot;ttl&quot;</span>)
        
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || value == <span class="hljs-literal">null</span>) {
            result.error(<span class="hljs-string">&quot;INVALID_ARGUMENT&quot;</span>, <span class="hljs-string">&quot;Key and value cannot be null&quot;</span>, <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">return</span>
        }
        
        <span class="hljs-keyword">val</span> success = <span class="hljs-keyword">try</span> {
            memoryCache.<span class="hljs-keyword">set</span>(key, value, ttl)
            diskCache.<span class="hljs-keyword">set</span>(key, value, ttl)
            <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            <span class="hljs-literal">false</span>
        }
        
        result.success(success)
    }
}
</code></pre>
<h4 id="内存缓存-memorycachekt">内存缓存 (<code>MemoryCache.kt</code>)</h4>
<pre><code class="language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryCache</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cache = LruCache&lt;String, CacheEntry&gt;(getMaxMemoryCacheSize())
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: String? {
        <span class="hljs-keyword">val</span> entry = cache.<span class="hljs-keyword">get</span>(key) ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        
        <span class="hljs-comment">// 检查是否过期</span>
        <span class="hljs-keyword">if</span> (entry.isExpired()) {
            cache.remove(key)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }
        
        <span class="hljs-keyword">return</span> entry.value
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(key: <span class="hljs-type">String</span>, value: <span class="hljs-type">String</span>, ttl: <span class="hljs-type">Long</span>? = <span class="hljs-literal">null</span>)</span></span> {
        <span class="hljs-keyword">val</span> expiryTime = ttl?.let { System.currentTimeMillis() + it }
        <span class="hljs-keyword">val</span> entry = CacheEntry(value, expiryTime)
        cache.put(key, entry)
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMaxMemoryCacheSize</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> {
        <span class="hljs-keyword">val</span> maxMemory = (Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span>).toInt()
        <span class="hljs-keyword">return</span> maxMemory / <span class="hljs-number">8</span>  <span class="hljs-comment">// 使用最大内存的1/8作为缓存大小</span>
    }
}

<span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheEntry</span></span>(
    <span class="hljs-keyword">val</span> value: String,
    <span class="hljs-keyword">val</span> expiryTime: <span class="hljs-built_in">Long</span>? = <span class="hljs-literal">null</span>
) {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isExpired</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> {
        <span class="hljs-keyword">return</span> expiryTime?.let { System.currentTimeMillis() &gt; it } ?: <span class="hljs-literal">false</span>
    }
}
</code></pre>
<h4 id="磁盘缓存-diskcachekt">磁盘缓存 (<code>DiskCache.kt</code>)</h4>
<pre><code class="language-kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiskCache</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> context: Context) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> cacheDir = File(context.cacheDir, <span class="hljs-string">&quot;one_app_cache&quot;</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> metadataFile = File(cacheDir, <span class="hljs-string">&quot;metadata.json&quot;</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> metadata = mutableMapOf&lt;String, CacheMetadata&gt;()
    
    <span class="hljs-keyword">init</span> {
        <span class="hljs-keyword">if</span> (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }
        loadMetadata()
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: String? {
        <span class="hljs-keyword">val</span> meta = metadata[key] ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        
        <span class="hljs-comment">// 检查是否过期</span>
        <span class="hljs-keyword">if</span> (meta.isExpired()) {
            delete(key)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
        }
        
        <span class="hljs-keyword">val</span> file = File(cacheDir, meta.filename)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (file.exists()) {
            <span class="hljs-keyword">try</span> {
                file.readText()
            } <span class="hljs-keyword">catch</span> (e: Exception) {
                <span class="hljs-literal">null</span>
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span>
    }
    
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(key: <span class="hljs-type">String</span>, value: <span class="hljs-type">String</span>, ttl: <span class="hljs-type">Long</span>? = <span class="hljs-literal">null</span>)</span></span> {
        <span class="hljs-keyword">val</span> filename = generateFilename(key)
        <span class="hljs-keyword">val</span> file = File(cacheDir, filename)
        
        <span class="hljs-keyword">try</span> {
            file.writeText(value)
            <span class="hljs-keyword">val</span> expiryTime = ttl?.let { System.currentTimeMillis() + it }
            metadata[key] = CacheMetadata(filename, expiryTime, System.currentTimeMillis())
            saveMetadata()
        } <span class="hljs-keyword">catch</span> (e: Exception) {
            <span class="hljs-comment">// 处理写入错误</span>
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateFilename</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: String {
        <span class="hljs-keyword">return</span> key.hashCode().toString() + <span class="hljs-string">&quot;.cache&quot;</span>
    }
}
</code></pre>
<h3 id="3-ios端实现">3. iOS端实现</h3>
<h4 id="主插件类-oneappcachepluginswift">主插件类 (<code>OneAppCachePlugin.swift</code>)</h4>
<pre><code class="language-swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OneAppCachePlugin</span>: <span class="hljs-title class_">NSObject</span>, <span class="hljs-title class_">FlutterPlugin</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> memoryCache: <span class="hljs-type">MemoryCache</span>!
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> diskCache: <span class="hljs-type">DiskCache</span>!
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">with</span> <span class="hljs-params">registrar</span>: <span class="hljs-type">FlutterPluginRegistrar</span>) {
        <span class="hljs-keyword">let</span> channel <span class="hljs-operator">=</span> <span class="hljs-type">FlutterMethodChannel</span>(name: <span class="hljs-string">&quot;one_app_cache_plugin&quot;</span>, 
                                         binaryMessenger: registrar.messenger())
        <span class="hljs-keyword">let</span> instance <span class="hljs-operator">=</span> <span class="hljs-type">OneAppCachePlugin</span>()
        instance.initializeCaches()
        registrar.addMethodCallDelegate(instance, channel: channel)
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initializeCaches</span>() {
        memoryCache <span class="hljs-operator">=</span> <span class="hljs-type">MemoryCache</span>()
        diskCache <span class="hljs-operator">=</span> <span class="hljs-type">DiskCache</span>()
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">call</span>: <span class="hljs-type">FlutterMethodCall</span>, <span class="hljs-params">result</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">FlutterResult</span>) {
        <span class="hljs-keyword">switch</span> call.method {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;get&quot;</span>:
            handleGet(call: call, result: result)
        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;set&quot;</span>:
            handleSet(call: call, result: result)
        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;delete&quot;</span>:
            handleDelete(call: call, result: result)
        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;clear&quot;</span>:
            handleClear(call: call, result: result)
        <span class="hljs-keyword">default</span>:
            result(<span class="hljs-type">FlutterMethodNotImplemented</span>)
        }
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">handleGet</span>(<span class="hljs-params">call</span>: <span class="hljs-type">FlutterMethodCall</span>, <span class="hljs-params">result</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-type">FlutterResult</span>) {
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> args <span class="hljs-operator">=</span> call.arguments <span class="hljs-keyword">as?</span> [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>],
              <span class="hljs-keyword">let</span> key <span class="hljs-operator">=</span> args[<span class="hljs-string">&quot;key&quot;</span>] <span class="hljs-keyword">as?</span> <span class="hljs-type">String</span> <span class="hljs-keyword">else</span> {
            result(<span class="hljs-type">FlutterError</span>(code: <span class="hljs-string">&quot;INVALID_ARGUMENT&quot;</span>, 
                               message: <span class="hljs-string">&quot;Key is required&quot;</span>, 
                               details: <span class="hljs-literal">nil</span>))
            <span class="hljs-keyword">return</span>
        }
        
        <span class="hljs-comment">// 多级缓存查找</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> memoryCache.get(key: key) {
            result(value)
            <span class="hljs-keyword">return</span>
        }
        
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> diskCache.get(key: key) {
            <span class="hljs-comment">// 提升到内存缓存</span>
            memoryCache.set(key: key, value: value)
            result(value)
            <span class="hljs-keyword">return</span>
        }
        
        result(<span class="hljs-literal">nil</span>)
    }
}
</code></pre>
<h2 id="缓存策略设计">缓存策略设计</h2>
<h3 id="淘汰策略">淘汰策略</h3>
<ol>
<li>
<p><strong>LRU (Least Recently Used)</strong></p>
<ul>
<li>淘汰最近最少使用的数据</li>
<li>适用于访问模式相对稳定的场景</li>
<li>实现简单，性能良好</li>
</ul>
</li>
<li>
<p><strong>LFU (Least Frequently Used)</strong></p>
<ul>
<li>淘汰使用频率最低的数据</li>
<li>适用于热点数据明显的场景</li>
<li>需要维护访问频率统计</li>
</ul>
</li>
<li>
<p><strong>TTL (Time To Live)</strong></p>
<ul>
<li>基于时间的自动过期</li>
<li>适用于时效性数据</li>
<li>可与其他策略组合使用</li>
</ul>
</li>
<li>
<p><strong>FIFO (First In First Out)</strong></p>
<ul>
<li>先进先出的简单策略</li>
<li>实现简单但效果有限</li>
<li>适用于对缓存效果要求不高的场景</li>
</ul>
</li>
</ol>
<h3 id="多级缓存架构">多级缓存架构</h3>
<pre><code>应用层
    ↓
Flutter缓存管理器
    ↓
L1: 内存缓存 (NSCache/LruCache)
    ↓
L2: 磁盘缓存 (本地文件系统)
    ↓
L3: 网络缓存 (HTTP缓存/CDN)
</code></pre>
<h2 id="性能优化">性能优化</h2>
<h3 id="内存优化">内存优化</h3>
<ul>
<li><strong>智能大小调整</strong>: 根据可用内存动态调整缓存大小</li>
<li><strong>内存压力监控</strong>: 监听系统内存压力事件</li>
<li><strong>延迟加载</strong>: 按需加载缓存数据</li>
<li><strong>压缩存储</strong>: 对大数据进行压缩存储</li>
</ul>
<h3 id="磁盘优化">磁盘优化</h3>
<ul>
<li><strong>异步I/O</strong>: 所有磁盘操作异步执行</li>
<li><strong>批量操作</strong>: 批量读写减少I/O次数</li>
<li><strong>文件压缩</strong>: 压缩存储节省空间</li>
<li><strong>定期清理</strong>: 定期清理过期和无效文件</li>
</ul>
<h3 id="网络优化">网络优化</h3>
<ul>
<li><strong>预加载</strong>: 预测性数据预加载</li>
<li><strong>增量更新</strong>: 仅传输变化数据</li>
<li><strong>并发控制</strong>: 限制并发网络请求</li>
<li><strong>断点续传</strong>: 支持大文件断点续传</li>
</ul>
<h2 id="数据安全">数据安全</h2>
<h3 id="加密存储">加密存储</h3>
<ul>
<li><strong>敏感数据加密</strong>: 对敏感缓存数据进行加密</li>
<li><strong>密钥管理</strong>: 安全的密钥存储和管理</li>
<li><strong>完整性验证</strong>: 数据完整性校验</li>
<li><strong>安全擦除</strong>: 安全删除敏感数据</li>
</ul>
<h3 id="权限控制">权限控制</h3>
<ul>
<li><strong>访问控制</strong>: 基于权限的缓存访问</li>
<li><strong>沙盒隔离</strong>: 应用间缓存数据隔离</li>
<li><strong>审计日志</strong>: 缓存访问审计记录</li>
<li><strong>异常监控</strong>: 异常访问行为监控</li>
</ul>
<h2 id="监控和诊断">监控和诊断</h2>
<h3 id="性能指标">性能指标</h3>
<pre><code class="language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheStats</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hitCount;      <span class="hljs-comment">// 命中次数</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> missCount;     <span class="hljs-comment">// 未命中次数</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> evictionCount; <span class="hljs-comment">// 淘汰次数</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> hitRate;    <span class="hljs-comment">// 命中率</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> size;          <span class="hljs-comment">// 当前大小</span>
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> maxSize;       <span class="hljs-comment">// 最大大小</span>
  
  <span class="hljs-built_in">double</span> <span class="hljs-keyword">get</span> hitRate =&gt; hitCount / (hitCount + missCount);
}
</code></pre>
<h3 id="诊断工具">诊断工具</h3>
<ul>
<li><strong>缓存命中率监控</strong>: 实时监控缓存效果</li>
<li><strong>内存使用分析</strong>: 分析内存使用模式</li>
<li><strong>性能分析器</strong>: 分析缓存操作性能</li>
<li><strong>调试界面</strong>: 可视化缓存状态</li>
</ul>
<h2 id="测试策略">测试策略</h2>
<h3 id="单元测试">单元测试</h3>
<ul>
<li><strong>缓存操作测试</strong>: 基本CRUD操作</li>
<li><strong>过期策略测试</strong>: TTL和淘汰策略</li>
<li><strong>并发安全测试</strong>: 多线程访问安全</li>
<li><strong>边界条件测试</strong>: 极限情况处理</li>
</ul>
<h3 id="集成测试">集成测试</h3>
<ul>
<li><strong>平台集成测试</strong>: 原生平台功能</li>
<li><strong>性能测试</strong>: 大数据量性能</li>
<li><strong>稳定性测试</strong>: 长时间运行稳定性</li>
<li><strong>兼容性测试</strong>: 不同设备和系统版本</li>
</ul>
<h3 id="压力测试">压力测试</h3>
<ul>
<li><strong>高并发测试</strong>: 大量并发访问</li>
<li><strong>大数据测试</strong>: 大容量数据处理</li>
<li><strong>内存压力测试</strong>: 低内存环境测试</li>
<li><strong>存储压力测试</strong>: 存储空间不足测试</li>
</ul>
<h2 id="最佳实践">最佳实践</h2>
<h3 id="使用建议">使用建议</h3>
<ol>
<li><strong>合理设置TTL</strong>: 根据数据特性设置合适的过期时间</li>
<li><strong>选择合适策略</strong>: 根据访问模式选择淘汰策略</li>
<li><strong>监控缓存效果</strong>: 定期检查命中率和性能指标</li>
<li><strong>控制缓存大小</strong>: 避免缓存过大影响性能</li>
</ol>
<h3 id="性能优化建议">性能优化建议</h3>
<ol>
<li><strong>预加载热点数据</strong>: 应用启动时预加载重要数据</li>
<li><strong>批量操作</strong>: 尽量使用批量API减少开销</li>
<li><strong>异步操作</strong>: 避免阻塞主线程</li>
<li><strong>合理清理</strong>: 定期清理过期和不需要的缓存</li>
</ol>
<h2 id="总结">总结</h2>
<p><code>one_app_cache_plugin</code> 作为 OneApp 的原生缓存插件，为Flutter应用提供了高效、可靠的多级缓存能力。通过智能的缓存策略、完善的性能优化和安全的数据保护，显著提升了应用的数据访问性能和用户体验。插件设计考虑了跨平台兼容性和可扩展性，能够适应不同的应用场景和性能要求。</p>

            
            
        </body>
        </html>